#  OpenAPI Petstore
#
# This spec is mainly for testing Petstore server and contains fake endpoints, models. Please do not use this for any other purpose. Special characters: \" \\
#
# The version of the OpenAPI document: 1.0.0
#
# Generated by: https://openapi-generator.tech
#

require "../../core"

require "../models/api_response"

require "../models/pet"

module PetStore
  class PetApi
    property api_client : ApiClient

    delegate client_side_validation, debugging, to: @api_client.config

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end

    # Add a new pet to the store
    #
    # @required @param csrftoken [String?] csrf token in cookie
    # @required @param pet [PetStore::Pet?] Pet object that needs to be added to the store
    # @return [Nil]
    def add_pet(
      *,
      csrftoken : String? = nil,
      pet : PetStore::Pet? = nil
    ) : Nil
      add_pet_with_http_info(csrftoken: csrftoken, pet: pet)
      nil
    end

    # Add a new pet to the store
    #
    # @required @param csrftoken [String?] csrf token in cookie
    # @required @param pet [PetStore::Pet?] Pet object that needs to be added to the store
    # @return [Tuple(Nil, Integer, Hash)] Nil, response status code and response headers
    def add_pet_with_http_info(
      *,
      csrftoken : String? = nil,
      pet : PetStore::Pet? = nil
    ) : Tuple(Nil, Int32, Hash(String, Array(String) | String))
      request = build_api_request_for_add_pet(csrftoken: csrftoken, pet: pet)

      body, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: PetApi#add_pet\nBody: #{body.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      Tuple.new(nil, status_code, headers)
    end

    # Add a new pet to the store
    #
    # @required @param csrftoken [String?] csrf token in cookie
    # @required @param pet [PetStore::Pet?] Pet object that needs to be added to the store
    # @return nil
    def add_pet(
      *,
      csrftoken : String? = nil,
      pet : PetStore::Pet? = nil,
      &block : Crest::Response ->
    ) : Nil
      build_api_request_for_add_pet(csrftoken: csrftoken, pet: pet).execute(&block)
    end

    ADD_PET_MAX_LENGTH_FOR_CSRFTOKEN = 64
    ADD_PET_MIN_LENGTH_FOR_CSRFTOKEN = 64

    # @return Crest::Request
    def build_api_request_for_add_pet(
      *,
      csrftoken : String? = nil,
      pet : PetStore::Pet? = nil
    ) : Crest::Request
      if debugging
        Log.debug { "Calling API: PetApi.add_pet ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"csrftoken\" is required and cannot be null") if csrftoken.nil?
        unless (_csrftoken = csrftoken).nil?
          OpenApi::PrimitiveValidator.validate_max_length("csrftoken", csrftoken.to_s.size, ADD_PET_MAX_LENGTH_FOR_CSRFTOKEN)
          OpenApi::PrimitiveValidator.validate_min_length("csrftoken", csrftoken.to_s.size, ADD_PET_MIN_LENGTH_FOR_CSRFTOKEN)
        end
        raise ArgumentError.new("\"pet\" is required and cannot be null") if pet.nil?
        unless (_pet = pet).nil?
          _pet.validate if _pet.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/pet"

      # header parameters
      header_params : Hash(String, String) = Hash(String, String).new
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/json", "application/xml"])

      # cookie parameters
      cookie_params : Hash(String, String) = Hash(String, String).new
      cookie_params["csrftoken"] = csrftoken.to_s if !csrftoken.nil?

      # query parameters
      query_params : Hash(String, (String | Array(String) | JSON::Any)) = Hash(String, (String | Array(String) | JSON::Any)).new

      # form parameters
      form_params : Array(Tuple(String, Crest::ParamsValue)) | Nil = nil

      # http body (model)
      post_body : IO | String | Nil = @api_client.encode(body: pet, content_type: header_params["Content-Type"]?) if !pet.nil?

      # auth_names
      auth_names = ["api_key_cookie", "petstore_auth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "PetApi.add_pet",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        cookie_params: cookie_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # Deletes a pet
    #
    # @required @param pet_id [Int64?] Pet id to delete
    # @optional @param api_key [String?]
    # @return [Nil]
    def delete_pet(
      *,
      pet_id : Int64? = nil,
      api_key : String? = nil
    ) : Nil
      delete_pet_with_http_info(pet_id: pet_id, api_key: api_key)
      nil
    end

    # Deletes a pet
    #
    # @required @param pet_id [Int64?] Pet id to delete
    # @optional @param api_key [String?]
    # @return [Tuple(Nil, Integer, Hash)] Nil, response status code and response headers
    def delete_pet_with_http_info(
      *,
      pet_id : Int64? = nil,
      api_key : String? = nil
    ) : Tuple(Nil, Int32, Hash(String, Array(String) | String))
      request = build_api_request_for_delete_pet(pet_id: pet_id, api_key: api_key)

      body, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: PetApi#delete_pet\nBody: #{body.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      Tuple.new(nil, status_code, headers)
    end

    # Deletes a pet
    #
    # @required @param pet_id [Int64?] Pet id to delete
    # @optional @param api_key [String?]
    # @return nil
    def delete_pet(
      *,
      pet_id : Int64? = nil,
      api_key : String? = nil,
      &block : Crest::Response ->
    ) : Nil
      build_api_request_for_delete_pet(pet_id: pet_id, api_key: api_key).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_delete_pet(
      *,
      pet_id : Int64? = nil,
      api_key : String? = nil
    ) : Crest::Request
      if debugging
        Log.debug { "Calling API: PetApi.delete_pet ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"pet_id\" is required and cannot be null") if pet_id.nil?
      end

      # resource path
      local_var_path = "/pet/{petId}".sub("{" + "petId" + "}", URI.encode_path(pet_id.to_s))

      # header parameters
      header_params : Hash(String, String) = Hash(String, String).new
      header_params["api_key"] = api_key.to_s if !api_key.nil?

      # cookie parameters
      cookie_params : Hash(String, String) = Hash(String, String).new

      # query parameters
      query_params : Hash(String, (String | Array(String) | JSON::Any)) = Hash(String, (String | Array(String) | JSON::Any)).new

      # form parameters
      form_params : Array(Tuple(String, Crest::ParamsValue)) | Nil = nil

      # http body (model)
      post_body : IO | String | Nil = nil

      # auth_names
      auth_names = ["petstore_auth"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "PetApi.delete_pet",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        cookie_params: cookie_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # Finds Pets by status
    # Multiple status values can be provided with comma separated strings
    # @required @param status [Array(String)?] Status values that need to be considered for filter
    # @return [Array(PetStore::Pet)]
    def find_pets_by_status(
      *,
      status : Array(String)? = nil
    ) : Array(PetStore::Pet)
      data, _status_code, _headers = find_pets_by_status_with_http_info(status: status)
      data
    end

    # Finds Pets by status
    # Multiple status values can be provided with comma separated strings
    # @required @param status [Array(String)?] Status values that need to be considered for filter
    # @return [Tuple(Array(PetStore::Pet), Integer, Hash)] Array(PetStore::Pet), response status code and response headers
    def find_pets_by_status_with_http_info(
      *,
      status : Array(String)? = nil
    ) : Tuple(Array(PetStore::Pet), Int32, Hash(String, Array(String) | String))
      request = build_api_request_for_find_pets_by_status(status: status)

      body, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: PetApi#find_pets_by_status\nBody: #{body.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      Tuple.new(Array(PetStore::Pet).from_json(body), status_code, headers)
    end

    # Finds Pets by status
    # Multiple status values can be provided with comma separated strings
    # @required @param status [Array(String)?] Status values that need to be considered for filter
    # @return nil
    def find_pets_by_status(
      *,
      status : Array(String)? = nil,
      &block : Crest::Response ->
    ) : Nil
      build_api_request_for_find_pets_by_status(status: status).execute(&block)
    end

    FIND_PETS_BY_STATUS_VALID_VALUES_FOR_STATUS = String.static_array("available", "pending", "sold")

    # @return Crest::Request
    def build_api_request_for_find_pets_by_status(
      *,
      status : Array(String)? = nil
    ) : Crest::Request
      if debugging
        Log.debug { "Calling API: PetApi.find_pets_by_status ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"status\" is required and cannot be null") if status.nil?
        unless (_status = status).nil?
          OpenApi::EnumValidator.validate("status", _status, FIND_PETS_BY_STATUS_VALID_VALUES_FOR_STATUS)
        end
      end

      # resource path
      local_var_path = "/pet/findByStatus"

      # header parameters
      header_params : Hash(String, String) = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/xml", "application/json"])

      # cookie parameters
      cookie_params : Hash(String, String) = Hash(String, String).new

      # query parameters
      query_params : Hash(String, (String | Array(String) | JSON::Any)) = Hash(String, (String | Array(String) | JSON::Any)).new
      query_params["status"] = @api_client.build_collection_param(status, "csv") if !status.nil? && !status.empty?

      # form parameters
      form_params : Array(Tuple(String, Crest::ParamsValue)) | Nil = nil

      # http body (model)
      post_body : IO | String | Nil = nil

      # auth_names
      auth_names = ["http_signature_test", "petstore_auth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "PetApi.find_pets_by_status",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        cookie_params: cookie_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # Finds Pets by tags
    # Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
    # @required @param tags [Array(String)?] Tags to filter by
    # @return [Array(PetStore::Pet)]
    def find_pets_by_tags(
      *,
      tags : Array(String)? = nil
    ) : Array(PetStore::Pet)
      data, _status_code, _headers = find_pets_by_tags_with_http_info(tags: tags)
      data
    end

    # Finds Pets by tags
    # Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
    # @required @param tags [Array(String)?] Tags to filter by
    # @return [Tuple(Array(PetStore::Pet), Integer, Hash)] Array(PetStore::Pet), response status code and response headers
    def find_pets_by_tags_with_http_info(
      *,
      tags : Array(String)? = nil
    ) : Tuple(Array(PetStore::Pet), Int32, Hash(String, Array(String) | String))
      request = build_api_request_for_find_pets_by_tags(tags: tags)

      body, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: PetApi#find_pets_by_tags\nBody: #{body.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      Tuple.new(Array(PetStore::Pet).from_json(body), status_code, headers)
    end

    # Finds Pets by tags
    # Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
    # @required @param tags [Array(String)?] Tags to filter by
    # @return nil
    def find_pets_by_tags(
      *,
      tags : Array(String)? = nil,
      &block : Crest::Response ->
    ) : Nil
      build_api_request_for_find_pets_by_tags(tags: tags).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_find_pets_by_tags(
      *,
      tags : Array(String)? = nil
    ) : Crest::Request
      if debugging
        Log.debug { "Calling API: PetApi.find_pets_by_tags ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"tags\" is required and cannot be null") if tags.nil?
      end

      # resource path
      local_var_path = "/pet/findByTags"

      # header parameters
      header_params : Hash(String, String) = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/xml", "application/json"])

      # cookie parameters
      cookie_params : Hash(String, String) = Hash(String, String).new

      # query parameters
      query_params : Hash(String, (String | Array(String) | JSON::Any)) = Hash(String, (String | Array(String) | JSON::Any)).new
      query_params["tags"] = @api_client.build_collection_param(tags, "csv") if !tags.nil? && !tags.empty?

      # form parameters
      form_params : Array(Tuple(String, Crest::ParamsValue)) | Nil = nil

      # http body (model)
      post_body : IO | String | Nil = nil

      # auth_names
      auth_names = ["http_signature_test", "petstore_auth"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "PetApi.find_pets_by_tags",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        cookie_params: cookie_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # Find pet by ID
    # Returns a single pet
    # @required @param pet_id [Int64?] ID of pet to return
    # @return [PetStore::Pet]
    def get_pet_by_id(
      *,
      pet_id : Int64? = nil
    ) : PetStore::Pet
      data, _status_code, _headers = get_pet_by_id_with_http_info(pet_id: pet_id)
      data
    end

    # Find pet by ID
    # Returns a single pet
    # @required @param pet_id [Int64?] ID of pet to return
    # @return [Tuple(PetStore::Pet, Integer, Hash)] PetStore::Pet, response status code and response headers
    def get_pet_by_id_with_http_info(
      *,
      pet_id : Int64? = nil
    ) : Tuple(PetStore::Pet, Int32, Hash(String, Array(String) | String))
      request = build_api_request_for_get_pet_by_id(pet_id: pet_id)

      body, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: PetApi#get_pet_by_id\nBody: #{body.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      Tuple.new(PetStore::Pet.from_json(body), status_code, headers)
    end

    # Find pet by ID
    # Returns a single pet
    # @required @param pet_id [Int64?] ID of pet to return
    # @return nil
    def get_pet_by_id(
      *,
      pet_id : Int64? = nil,
      &block : Crest::Response ->
    ) : Nil
      build_api_request_for_get_pet_by_id(pet_id: pet_id).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_get_pet_by_id(
      *,
      pet_id : Int64? = nil
    ) : Crest::Request
      if debugging
        Log.debug { "Calling API: PetApi.get_pet_by_id ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"pet_id\" is required and cannot be null") if pet_id.nil?
      end

      # resource path
      local_var_path = "/pet/{petId}".sub("{" + "petId" + "}", URI.encode_path(pet_id.to_s))

      # header parameters
      header_params : Hash(String, String) = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/xml", "application/json"])

      # cookie parameters
      cookie_params : Hash(String, String) = Hash(String, String).new

      # query parameters
      query_params : Hash(String, (String | Array(String) | JSON::Any)) = Hash(String, (String | Array(String) | JSON::Any)).new

      # form parameters
      form_params : Array(Tuple(String, Crest::ParamsValue)) | Nil = nil

      # http body (model)
      post_body : IO | String | Nil = nil

      # auth_names
      auth_names = ["api_key"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "PetApi.get_pet_by_id",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        cookie_params: cookie_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # Update an existing pet
    #
    # @required @param pet [PetStore::Pet?] Pet object that needs to be added to the store
    # @return [Nil]
    def update_pet(
      *,
      pet : PetStore::Pet? = nil
    ) : Nil
      update_pet_with_http_info(pet: pet)
      nil
    end

    # Update an existing pet
    #
    # @required @param pet [PetStore::Pet?] Pet object that needs to be added to the store
    # @return [Tuple(Nil, Integer, Hash)] Nil, response status code and response headers
    def update_pet_with_http_info(
      *,
      pet : PetStore::Pet? = nil
    ) : Tuple(Nil, Int32, Hash(String, Array(String) | String))
      request = build_api_request_for_update_pet(pet: pet)

      body, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: PetApi#update_pet\nBody: #{body.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      Tuple.new(nil, status_code, headers)
    end

    # Update an existing pet
    #
    # @required @param pet [PetStore::Pet?] Pet object that needs to be added to the store
    # @return nil
    def update_pet(
      *,
      pet : PetStore::Pet? = nil,
      &block : Crest::Response ->
    ) : Nil
      build_api_request_for_update_pet(pet: pet).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_update_pet(
      *,
      pet : PetStore::Pet? = nil
    ) : Crest::Request
      if debugging
        Log.debug { "Calling API: PetApi.update_pet ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"pet\" is required and cannot be null") if pet.nil?
        unless (_pet = pet).nil?
          _pet.validate if _pet.is_a?(OpenApi::Validatable)
        end
      end

      # resource path
      local_var_path = "/pet"

      # header parameters
      header_params : Hash(String, String) = Hash(String, String).new
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/json", "application/xml"])

      # cookie parameters
      cookie_params : Hash(String, String) = Hash(String, String).new

      # query parameters
      query_params : Hash(String, (String | Array(String) | JSON::Any)) = Hash(String, (String | Array(String) | JSON::Any)).new

      # form parameters
      form_params : Array(Tuple(String, Crest::ParamsValue)) | Nil = nil

      # http body (model)
      post_body : IO | String | Nil = @api_client.encode(body: pet, content_type: header_params["Content-Type"]?) if !pet.nil?

      # auth_names
      auth_names = ["http_signature_test", "petstore_auth"]

      @api_client.build_api_request(
        http_method: :"PUT",
        path: local_var_path,
        operation: "PetApi.update_pet",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        cookie_params: cookie_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # Updates a pet in the store with form data
    #
    # @required @param pet_id [Int64?] ID of pet that needs to be updated
    # @optional @param name [String?] Updated name of the pet
    # @optional @param status [String?] Updated status of the pet
    # @return [Nil]
    def update_pet_with_form(
      *,
      pet_id : Int64? = nil,
      name : String? = nil,
      status : String? = nil
    ) : Nil
      update_pet_with_form_with_http_info(pet_id: pet_id, name: name, status: status)
      nil
    end

    # Updates a pet in the store with form data
    #
    # @required @param pet_id [Int64?] ID of pet that needs to be updated
    # @optional @param name [String?] Updated name of the pet
    # @optional @param status [String?] Updated status of the pet
    # @return [Tuple(Nil, Integer, Hash)] Nil, response status code and response headers
    def update_pet_with_form_with_http_info(
      *,
      pet_id : Int64? = nil,
      name : String? = nil,
      status : String? = nil
    ) : Tuple(Nil, Int32, Hash(String, Array(String) | String))
      request = build_api_request_for_update_pet_with_form(pet_id: pet_id, name: name, status: status)

      body, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: PetApi#update_pet_with_form\nBody: #{body.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      Tuple.new(nil, status_code, headers)
    end

    # Updates a pet in the store with form data
    #
    # @required @param pet_id [Int64?] ID of pet that needs to be updated
    # @optional @param name [String?] Updated name of the pet
    # @optional @param status [String?] Updated status of the pet
    # @return nil
    def update_pet_with_form(
      *,
      pet_id : Int64? = nil,
      name : String? = nil,
      status : String? = nil,
      &block : Crest::Response ->
    ) : Nil
      build_api_request_for_update_pet_with_form(pet_id: pet_id, name: name, status: status).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_update_pet_with_form(
      *,
      pet_id : Int64? = nil,
      name : String? = nil,
      status : String? = nil
    ) : Crest::Request
      if debugging
        Log.debug { "Calling API: PetApi.update_pet_with_form ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"pet_id\" is required and cannot be null") if pet_id.nil?
      end

      # resource path
      local_var_path = "/pet/{petId}".sub("{" + "petId" + "}", URI.encode_path(pet_id.to_s))

      # header parameters
      header_params : Hash(String, String) = Hash(String, String).new
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/x-www-form-urlencoded"])

      # cookie parameters
      cookie_params : Hash(String, String) = Hash(String, String).new

      # query parameters
      query_params : Hash(String, (String | Array(String) | JSON::Any)) = Hash(String, (String | Array(String) | JSON::Any)).new

      # form parameters
      form_params : Array(Tuple(String, Crest::ParamsValue)) | Nil = Array(Tuple(String, Crest::ParamsValue)).new
      form_params << Tuple(String, Crest::ParamsValue).new("name", name.to_s) if !name.nil?
      form_params << Tuple(String, Crest::ParamsValue).new("status", status.to_s) if !status.nil?

      # http body (model)
      post_body : IO | String | Nil = nil

      # auth_names
      auth_names = ["petstore_auth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "PetApi.update_pet_with_form",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        cookie_params: cookie_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # uploads an image
    #
    # @required @param pet_id [Int64?] ID of pet to update
    # @optional @param additional_metadata [String?] Additional data to pass to server
    # @optional @param file [::File?] file to upload
    # @return [PetStore::ApiResponse]
    def upload_file(
      *,
      pet_id : Int64? = nil,
      additional_metadata : String? = nil,
      file : ::File? = nil
    ) : PetStore::ApiResponse
      data, _status_code, _headers = upload_file_with_http_info(pet_id: pet_id, additional_metadata: additional_metadata, file: file)
      data
    end

    # uploads an image
    #
    # @required @param pet_id [Int64?] ID of pet to update
    # @optional @param additional_metadata [String?] Additional data to pass to server
    # @optional @param file [::File?] file to upload
    # @return [Tuple(PetStore::ApiResponse, Integer, Hash)] PetStore::ApiResponse, response status code and response headers
    def upload_file_with_http_info(
      *,
      pet_id : Int64? = nil,
      additional_metadata : String? = nil,
      file : ::File? = nil
    ) : Tuple(PetStore::ApiResponse, Int32, Hash(String, Array(String) | String))
      request = build_api_request_for_upload_file(pet_id: pet_id, additional_metadata: additional_metadata, file: file)

      body, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: PetApi#upload_file\nBody: #{body.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      Tuple.new(PetStore::ApiResponse.from_json(body), status_code, headers)
    end

    # uploads an image
    #
    # @required @param pet_id [Int64?] ID of pet to update
    # @optional @param additional_metadata [String?] Additional data to pass to server
    # @optional @param file [::File?] file to upload
    # @return nil
    def upload_file(
      *,
      pet_id : Int64? = nil,
      additional_metadata : String? = nil,
      file : ::File? = nil,
      &block : Crest::Response ->
    ) : Nil
      build_api_request_for_upload_file(pet_id: pet_id, additional_metadata: additional_metadata, file: file).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_upload_file(
      *,
      pet_id : Int64? = nil,
      additional_metadata : String? = nil,
      file : ::File? = nil
    ) : Crest::Request
      if debugging
        Log.debug { "Calling API: PetApi.upload_file ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"pet_id\" is required and cannot be null") if pet_id.nil?
      end

      # resource path
      local_var_path = "/pet/{petId}/uploadImage".sub("{" + "petId" + "}", URI.encode_path(pet_id.to_s))

      # header parameters
      header_params : Hash(String, String) = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["multipart/form-data"])

      # cookie parameters
      cookie_params : Hash(String, String) = Hash(String, String).new

      # query parameters
      query_params : Hash(String, (String | Array(String) | JSON::Any)) = Hash(String, (String | Array(String) | JSON::Any)).new

      # form parameters
      form_params : Array(Tuple(String, Crest::ParamsValue)) | Nil = Array(Tuple(String, Crest::ParamsValue)).new
      form_params << Tuple(String, Crest::ParamsValue).new("additionalMetadata", additional_metadata.to_s) if !additional_metadata.nil?
      form_params << Tuple(String, Crest::ParamsValue).new("file", file) if !file.nil?

      # http body (model)
      post_body : IO | String | Nil = nil

      # auth_names
      auth_names = ["petstore_auth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "PetApi.upload_file",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        cookie_params: cookie_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # uploads an image (required)
    #
    # @required @param pet_id [Int64?] ID of pet to update
    # @required @param required_file [::File?] file to upload
    # @optional @param additional_metadata [String?] Additional data to pass to server
    # @return [PetStore::ApiResponse]
    def upload_file_with_required_file(
      *,
      pet_id : Int64? = nil,
      required_file : ::File? = nil,
      additional_metadata : String? = nil
    ) : PetStore::ApiResponse
      data, _status_code, _headers = upload_file_with_required_file_with_http_info(pet_id: pet_id, required_file: required_file, additional_metadata: additional_metadata)
      data
    end

    # uploads an image (required)
    #
    # @required @param pet_id [Int64?] ID of pet to update
    # @required @param required_file [::File?] file to upload
    # @optional @param additional_metadata [String?] Additional data to pass to server
    # @return [Tuple(PetStore::ApiResponse, Integer, Hash)] PetStore::ApiResponse, response status code and response headers
    def upload_file_with_required_file_with_http_info(
      *,
      pet_id : Int64? = nil,
      required_file : ::File? = nil,
      additional_metadata : String? = nil
    ) : Tuple(PetStore::ApiResponse, Int32, Hash(String, Array(String) | String))
      request = build_api_request_for_upload_file_with_required_file(pet_id: pet_id, required_file: required_file, additional_metadata: additional_metadata)

      body, status_code, headers = @api_client.execute_api_request(request)

      if debugging
        Log.debug { "API called: PetApi#upload_file_with_required_file\nBody: #{body.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      Tuple.new(PetStore::ApiResponse.from_json(body), status_code, headers)
    end

    # uploads an image (required)
    #
    # @required @param pet_id [Int64?] ID of pet to update
    # @required @param required_file [::File?] file to upload
    # @optional @param additional_metadata [String?] Additional data to pass to server
    # @return nil
    def upload_file_with_required_file(
      *,
      pet_id : Int64? = nil,
      required_file : ::File? = nil,
      additional_metadata : String? = nil,
      &block : Crest::Response ->
    ) : Nil
      build_api_request_for_upload_file_with_required_file(pet_id: pet_id, required_file: required_file, additional_metadata: additional_metadata).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_upload_file_with_required_file(
      *,
      pet_id : Int64? = nil,
      required_file : ::File? = nil,
      additional_metadata : String? = nil
    ) : Crest::Request
      if debugging
        Log.debug { "Calling API: PetApi.upload_file_with_required_file ..." }
      end

      if client_side_validation
        raise ArgumentError.new("\"pet_id\" is required and cannot be null") if pet_id.nil?

        raise ArgumentError.new("\"required_file\" is required and cannot be null") if required_file.nil?
      end

      # resource path
      local_var_path = "/fake/{petId}/uploadImageWithRequiredFile".sub("{" + "petId" + "}", URI.encode_path(pet_id.to_s))

      # header parameters
      header_params : Hash(String, String) = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["multipart/form-data"])

      # cookie parameters
      cookie_params : Hash(String, String) = Hash(String, String).new

      # query parameters
      query_params : Hash(String, (String | Array(String) | JSON::Any)) = Hash(String, (String | Array(String) | JSON::Any)).new

      # form parameters
      form_params : Array(Tuple(String, Crest::ParamsValue)) | Nil = Array(Tuple(String, Crest::ParamsValue)).new
      form_params << Tuple(String, Crest::ParamsValue).new("additionalMetadata", additional_metadata.to_s) if !additional_metadata.nil?
      form_params << Tuple(String, Crest::ParamsValue).new("requiredFile", required_file) if !required_file.nil?

      # http body (model)
      post_body : IO | String | Nil = nil

      # auth_names
      auth_names = ["petstore_auth"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "PetApi.upload_file_with_required_file",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        cookie_params: cookie_params,
        query_params: query_params,
        form_params: form_params
      )
    end
  end
end
